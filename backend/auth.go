package main

import (
	"bytes"
	"crypto/sha256"
	"math/rand"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type user struct {
	session_id       string
	is_guest         bool
	username         string
	data             string //will only be used for guests, since we don't want to store data generated by guests into database
	time_last_action int    //in minutes, uses application clock
}

var time_out_min int = 30

//this function generates a session_id for any successful login activity
//it will store the successfully logged in user to (slice user), and return the generated session_id as a string
func generate_session_id(is_guest bool, username string) string {
	//for guests, the session_id is generated by calculating the hash of (the current time + a random number)
	if is_guest {
		ans_byte := sha256.Sum256([]byte(time.Now().String() + strconv.Itoa(rand.Intn(100))))
		ans := string(ans_byte[:])
		var to_append user = user{session_id: ans, is_guest: true, username: "", data: "", time_last_action: min_since_start}
		lck.Lock()
		logged_users = append(logged_users, to_append)
		lck.Unlock()
		return ans
	}

	//for registered users, the session_id is generated by calculating the hash of (the current time + username)
	ans_byte := sha256.Sum256([]byte(time.Now().String() + username))
	ans := string(ans_byte[:])
	var to_append user = user{session_id: ans, is_guest: false, username: username, data: "", time_last_action: min_since_start}
	lck.Lock()
	logged_users = append(logged_users, to_append)
	lck.Unlock()
	return ans
}

//This function logs a user in
//http request body: "guest" || "<username>,<password>"
//http response body: session_id || error message(status 403)
func login(w http.ResponseWriter, req *http.Request) {
	w.Header().Set("Content-Type", "text/plain; charset=UTF-8")

	buf := new(bytes.Buffer)
	buf.ReadFrom(req.Body)
	var content string = buf.String()

	//since any request with length 3 is not possibly valid, return immediately with 403
	if len(content) < 3 {
		w.WriteHeader(http.StatusForbidden)
		w.Write([]byte("Invalid credentials"))
		return
	}

	//if user wants to login as guest
	if content == "guest" {
		w.WriteHeader(http.StatusOK)
		var ssid string = generate_session_id(true, "")
		w.Write([]byte(ssid))
		return
	}

	data := strings.SplitAfter(content, ",")
	var username string = data[0]
	var passwd string = data[1] //notice this is asserted to be a hashed string
	username = username[:len(username)-1]

	//TODO: add username format validation for security

	var ori_pw string = execute_sql("SELECT passwd FROM registered_users WHERE username="+username+";", 1, true)

	//If there is no entry matching the provided username, return 403
	if len(ori_pw) == 0 {
		w.WriteHeader(http.StatusForbidden)
		w.Write([]byte("User does not exist"))
		return
	}

	hashed_crt_pw_byte := sha256.Sum256([]byte(ori_pw))
	var hashed_crt_pw string = string(hashed_crt_pw_byte[:])
	if hashed_crt_pw == passwd {
		w.WriteHeader(http.StatusOK)
		var ssid string = generate_session_id(false, username)
		w.Write([]byte(ssid))
		return
	}

	w.WriteHeader(http.StatusForbidden)
	w.Write([]byte("Invalid credentials"))

}

//This function logs out a user
//http request body: session_id
//http response body: "Successfully logged out"(200) || "Session ID not recognized, not logged in or session expired?"(403)
func logout(w http.ResponseWriter, req *http.Request) {
	w.Header().Set("Content-Type", "text/plain; charset=UTF-8")

	buf := new(bytes.Buffer)
	buf.ReadFrom(req.Body)
	var content string = buf.String()

	lck.Lock()
	for i := 0; i < len(logged_users); i++ {
		if logged_users[i].session_id == content {
			logged_users = remove_user(logged_users, i)
			lck.Unlock()
			w.WriteHeader(http.StatusOK)
			w.Write([]byte("Successfully logged out"))
			return
		}
	}
	lck.Unlock()
	w.WriteHeader(http.StatusForbidden)
	w.Write([]byte("Session ID not recognized, not logged in or session expired?"))
}

//This function registers a new user
//auto-login if successfully registered
//http request body: "<username>,<password>""
//http response body: session_id(200) || "Username taken"(403)
func register(w http.ResponseWriter, req *http.Request) {
	w.Header().Set("Content-Type", "text/plain; charset=UTF-8")

	buf := new(bytes.Buffer)
	buf.ReadFrom(req.Body)
	var content string = buf.String()

	data := strings.SplitAfter(content, ",")
	var username string = data[0]
	var passwd string = data[1] //notice this is asserted to be the original string
	username = username[:len(username)-1]

	var past_user string = execute_sql("SELECT passwd FROM registered_users WHERE username="+username+";", 1, true)
	if past_user != "" {
		w.WriteHeader(http.StatusForbidden)
		w.Write([]byte("Username taken"))
		return
	}

	execute_sql("INSERT INTO registered_users ('username', 'passwd') VALUES ('"+username+"','"+passwd+"');", 0, false)

	w.WriteHeader(http.StatusOK)
	var ssid string = generate_session_id(false, username)
	w.Write([]byte(ssid))
	return

}

//This function handles the time-out feature
func expirer() {
	for true {
		time.Sleep(time.Second * 60 * 2)
		lck.Lock()
		for i := 0; i < len(logged_users); i++ {
			if min_since_start-logged_users[i].time_last_action > time_out_min {
				logged_users = remove_user(logged_users, i)
				i--
			}
		}
		lck.Unlock()
	}
}
